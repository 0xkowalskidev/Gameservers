<!-- Server header with Alpine.js state management -->
<div id="gameserver-header"
     x-data="gameserverHeader('{{.Gameserver.ID}}', '{{.Gameserver.Status}}', {{.Gameserver.Status.IsTransitional}})"
     x-init="init()"
     @cleanup="cleanup()"
     class="mb-6">

  <!-- Header row -->
  <div class="flex items-center justify-between gap-4 mb-4">
    <!-- Left: Icon, name, status -->
    <div class="flex items-center gap-4 min-w-0">
      {{if .Gameserver.IconPath}}
      <img src="{{.Gameserver.IconPath}}" alt="{{.Gameserver.GameType}}" class="w-12 h-12 rounded-lg object-cover flex-shrink-0">
      {{else}}
      <div class="w-12 h-12 rounded-lg bg-gradient-to-br from-blue-500 to-blue-600 flex items-center justify-center flex-shrink-0">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2"></path>
        </svg>
      </div>
      {{end}}

      <div class="min-w-0">
        <div class="flex items-center gap-3">
          <h1 class="text-2xl font-bold text-gray-900 dark:text-gray-100 truncate">{{.Gameserver.Name}}</h1>
          <span class="inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full text-xs font-medium" :class="statusBadgeClasses">
            <span class="w-1.5 h-1.5 rounded-full" :class="indicatorClass"></span>
            <span x-text="statusText"></span>
          </span>
        </div>
        <div class="text-sm text-gray-500 dark:text-gray-400 mt-0.5">
          {{.Gameserver.GameType}}{{$gamePort := .Gameserver.GetGamePort}}{{if and $gamePort publicAddress}} Â· <span class="font-mono">{{publicAddress}}:{{$gamePort.HostPort}}</span>{{end}}
        </div>
      </div>
    </div>

    <!-- Right: Actions -->
    <div class="flex items-center gap-2 flex-shrink-0">
      <!-- Transitional state -->
      <template x-if="isTransitional">
        <button disabled class="inline-flex items-center gap-2 px-4 py-2 bg-gray-100 dark:bg-gray-700 text-gray-400 text-sm font-medium rounded-lg cursor-not-allowed">
          <svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
          </svg>
          <span x-text="transitionText"></span>
        </button>
      </template>

      <!-- Running state -->
      <template x-if="!isTransitional && status === 'running'">
        <div class="flex items-center gap-2">
          <button @click="doAction('restart')" class="inline-flex items-center gap-2 px-3 py-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 text-sm font-medium rounded-lg transition-colors">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
            </svg>
            Restart
          </button>
          <button @click="doAction('stop')" class="inline-flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded-lg transition-colors">
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="1"/></svg>
            Stop
          </button>
        </div>
      </template>

      <!-- Stopped state -->
      <template x-if="!isTransitional && status !== 'running'">
        <button @click="doAction('start')" class="inline-flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
          Start
        </button>
      </template>
    </div>
  </div>

  <!-- Live stats bar: Only shown when running -->
  <template x-if="status === 'running'">
    <div class="flex items-center gap-6 text-sm mb-4">
      <!-- Players -->
      <div class="flex items-center gap-2">
        <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
        <template x-if="query.online">
          <span class="text-gray-900 dark:text-gray-100">
            <span class="font-semibold" x-text="query.players?.current || 0"></span><span class="text-gray-400"> / </span><span x-text="query.players?.max || 0"></span>
          </span>
        </template>
        <template x-if="!query.online">
          <span class="text-gray-400">--</span>
        </template>
      </div>

      <!-- Ping -->
      <div class="flex items-center gap-2">
        <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
        </svg>
        <template x-if="query.online && query.ping">
          <span class="text-gray-900 dark:text-gray-100"><span class="font-semibold" x-text="query.ping"></span><span class="text-gray-500 text-xs ml-0.5">ms</span></span>
        </template>
        <template x-if="!query.online || !query.ping">
          <span class="text-gray-400">--</span>
        </template>
      </div>

      <div class="h-4 w-px bg-gray-200 dark:bg-gray-700"></div>

      <!-- CPU -->
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-500 dark:text-gray-400 w-7">CPU</span>
        <div class="w-16 h-1.5 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
          <div class="h-full rounded-full transition-all duration-300"
               :class="stats.cpu > 80 ? 'bg-red-500' : stats.cpu > 50 ? 'bg-amber-500' : 'bg-emerald-500'"
               :style="`width: ${Math.min(stats.cpu, 100)}%`"></div>
        </div>
        <span class="text-xs text-gray-600 dark:text-gray-300 w-7 font-mono" x-text="`${stats.cpu.toFixed(0)}%`"></span>
      </div>

      <!-- Memory -->
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-500 dark:text-gray-400 w-7">MEM</span>
        <div class="w-16 h-1.5 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
          <div class="h-full rounded-full transition-all duration-300"
               :class="stats.memoryPercent > 80 ? 'bg-red-500' : stats.memoryPercent > 50 ? 'bg-amber-500' : 'bg-blue-500'"
               :style="`width: ${Math.min(stats.memoryPercent, 100)}%`"></div>
        </div>
        <span class="text-xs text-gray-600 dark:text-gray-300 font-mono" x-text="`${stats.memoryUsageGB.toFixed(1)}G`"></span>
      </div>
    </div>
  </template>

  <!-- Startup Logs: Shown during startup states -->
  <template x-if="showLogs">
    <div class="bg-gray-900 rounded-lg p-3 mb-4 font-mono text-xs leading-relaxed max-h-28 overflow-hidden">
      <template x-for="(log, index) in logs.slice(-6)" :key="index">
        <div class="text-green-400 truncate" x-text="log"></div>
      </template>
      <template x-if="logs.length === 0">
        <div class="text-gray-600">Waiting for output...</div>
      </template>
    </div>
  </template>
</div>

<script>
function gameserverHeader(id, initialStatus, initialIsTransitional) {
  return {
    id: id,
    status: initialStatus,
    isTransitional: initialIsTransitional,
    pollInterval: null,
    statsEventSource: null,
    logsEventSource: null,
    queryInterval: null,
    stats: { cpu: 0, memoryUsageGB: 0, memoryLimitGB: 0, memoryPercent: 0 },
    query: { online: false, players: null, map: null, ping: null },
    logs: [],

    get statusBadgeClasses() {
      const classes = {
        running: 'bg-green-100 text-green-700 dark:bg-green-500/20 dark:text-green-400',
        stopped: 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400',
        pulling_image: 'bg-blue-100 text-blue-700 dark:bg-blue-500/20 dark:text-blue-400',
        creating_container: 'bg-blue-100 text-blue-700 dark:bg-blue-500/20 dark:text-blue-400',
        starting_container: 'bg-amber-100 text-amber-700 dark:bg-amber-500/20 dark:text-amber-400',
        waiting_ready: 'bg-amber-100 text-amber-700 dark:bg-amber-500/20 dark:text-amber-400',
        stopping: 'bg-orange-100 text-orange-700 dark:bg-orange-500/20 dark:text-orange-400',
        deleting: 'bg-red-100 text-red-700 dark:bg-red-500/20 dark:text-red-400',
        error: 'bg-red-100 text-red-700 dark:bg-red-500/20 dark:text-red-400',
      };
      return classes[this.status] || 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400';
    },

    get indicatorClass() {
      const classes = {
        running: 'bg-green-500',
        stopped: 'bg-gray-400',
        pulling_image: 'bg-blue-500 animate-pulse',
        creating_container: 'bg-blue-500 animate-pulse',
        starting_container: 'bg-amber-500 animate-pulse',
        waiting_ready: 'bg-amber-500 animate-pulse',
        stopping: 'bg-orange-500 animate-pulse',
        deleting: 'bg-red-500 animate-pulse',
        error: 'bg-red-500',
      };
      return classes[this.status] || 'bg-gray-400';
    },

    get statusText() {
      const texts = {
        running: 'Running',
        stopped: 'Stopped',
        pulling_image: 'Pulling',
        creating_container: 'Creating',
        starting_container: 'Starting',
        waiting_ready: 'Starting',
        stopping: 'Stopping',
        deleting: 'Deleting',
        error: 'Error',
      };
      return texts[this.status] || this.status;
    },

    get transitionText() {
      const texts = {
        pulling_image: 'Pulling...',
        creating_container: 'Creating...',
        starting_container: 'Starting...',
        waiting_ready: 'Starting...',
        stopping: 'Stopping...',
        deleting: 'Deleting...',
      };
      return texts[this.status] || 'Processing...';
    },

    get showLogs() {
      return ['starting_container', 'waiting_ready'].includes(this.status);
    },

    init() {
      this.startStatusPolling();
      this.updateLogStreaming();
      if (this.status === 'running') {
        this.startStatsStream();
        this.startQueryPolling();
      }
    },

    async doAction(action) {
      this.isTransitional = true;
      try {
        await fetch(`/gameservers/${this.id}/${action}`, { method: 'POST' });
        const resp = await fetch(`/gameservers/${this.id}/status`);
        if (resp.ok) {
          const data = await resp.json();
          this.handleStatusChange(data.status, data.isTransitional);
        }
      } catch (e) {
        console.error(`Action ${action} failed:`, e);
        this.isTransitional = false;
      }
    },

    startStatusPolling() {
      if (this.pollInterval) return;

      this.pollInterval = setInterval(async () => {
        try {
          const resp = await fetch(`/gameservers/${this.id}/status`);
          if (resp.ok) {
            const data = await resp.json();
            this.handleStatusChange(data.status, data.isTransitional);
          } else if (resp.status === 404) {
            window.location.href = '/gameservers';
          }
        } catch (e) {
          console.error('Status poll failed:', e);
        }
      }, 2000);
    },

    handleStatusChange(newStatus, newIsTransitional) {
      const prevStatus = this.status;
      this.status = newStatus;
      this.isTransitional = newIsTransitional;

      if (prevStatus !== 'running' && this.status === 'running') {
        this.startStatsStream();
        this.startQueryPolling();
      } else if (prevStatus === 'running' && this.status !== 'running') {
        this.stopStatsStream();
        this.stopQueryPolling();
      }

      if (prevStatus !== this.status) {
        this.updateLogStreaming();
        window.dispatchEvent(new CustomEvent('gameserver-status', {
          detail: { id: this.id, status: this.status, isTransitional: this.isTransitional }
        }));
      }
    },

    startStatsStream() {
      if (this.statsEventSource) return;

      this.statsEventSource = new EventSource(`/gameservers/${this.id}/stats`);
      this.statsEventSource.addEventListener('stats', (e) => {
        try {
          const data = JSON.parse(e.data);
          this.stats = {
            cpu: data.cpu || 0,
            memoryUsageGB: data.memoryUsageGB || 0,
            memoryLimitGB: data.memoryLimitGB || 0,
            memoryPercent: data.memoryPercent || 0
          };
        } catch (err) {
          console.error('Failed to parse stats:', err);
        }
      });
    },

    stopStatsStream() {
      if (this.statsEventSource) {
        this.statsEventSource.close();
        this.statsEventSource = null;
      }
    },

    startQueryPolling() {
      if (this.queryInterval) return;

      this.fetchQuery();
      this.queryInterval = setInterval(() => this.fetchQuery(), 5000);
    },

    stopQueryPolling() {
      if (this.queryInterval) {
        clearInterval(this.queryInterval);
        this.queryInterval = null;
      }
      this.query = { online: false, players: null, map: null, ping: null };
    },

    async fetchQuery() {
      try {
        const resp = await fetch(`/gameservers/${this.id}/query`);
        if (resp.ok) {
          const data = await resp.json();
          this.query = {
            online: data.online || false,
            players: data.players || null,
            map: data.map || null,
            ping: data.ping || null
          };
        }
      } catch (e) {
        console.error('Query poll failed:', e);
      }
    },

    updateLogStreaming() {
      if (this.showLogs && !this.logsEventSource) {
        this.startLogStream();
      } else if (!this.showLogs && this.logsEventSource) {
        this.stopLogStream();
      }
    },

    startLogStream() {
      this.logs = [];
      this.logsEventSource = new EventSource(`/gameservers/${this.id}/logs`);
      this.logsEventSource.addEventListener('log', (event) => {
        const div = document.createElement('div');
        div.innerHTML = event.data;
        const text = div.textContent || div.innerText;
        if (text.trim()) {
          this.logs.push(text);
          if (this.logs.length > 20) {
            this.logs = this.logs.slice(-20);
          }
        }
      });
      this.logsEventSource.onerror = () => {
        this.stopLogStream();
      };
    },

    stopLogStream() {
      if (this.logsEventSource) {
        this.logsEventSource.close();
        this.logsEventSource = null;
      }
    },

    cleanup() {
      if (this.pollInterval) {
        clearInterval(this.pollInterval);
        this.pollInterval = null;
      }
      this.stopStatsStream();
      this.stopQueryPolling();
      this.stopLogStream();
    }
  };
}
</script>
